Texture2D inputTexture : register(t0); // typically depth but normal.b is cool too
SamplerState samplerState : register(s0);

cbuffer BlurBuffer : register(b0)
{
    int isDepth;
    float proj43;
    float proj33;
    int kernelRadius;
    
    float2 texelSize; // = 1.0 / texture dimensions
    float2 pad;
    
    float4 weights[4]; // up to max radius
};

struct PixelInputType
{
    float2 uv : TEXCOORD0;
    float4 position : SV_POSITION;
};

float4 Sample(float2 uv)
{
    if (isDepth == 1)
    {
        float z = inputTexture.Sample(samplerState, uv).r;
        z = (z * (proj33 - 1.0)) / (proj33 - z);
        return float4(z.rrr, 1);
    }
    else
    {
        return inputTexture.Sample(samplerState, uv);
    }
}

float4 GaussianH(PixelInputType input) : SV_Target
{
    float4 color = weights[0][0] * Sample(input.uv);

    [unroll]
    for (int i = 1; i <= kernelRadius; ++i)
    {
        float w = weights[i / 4][i % 4];
        float2 of = (texelSize.x, 0);
        color += w * (Sample(input.uv + of) +
        Sample(input.uv - of));
    }

    return color;
}

float4 GaussianV(PixelInputType input) : SV_Target
{
    float4 color = weights[0][0] * inputTexture.Sample(samplerState, input.uv);

    [unroll]
    for (int i = 1; i <= kernelRadius; ++i)
    {
        float w = weights[i / 4][i % 4];
        float2 of = (0, texelSize.y);
        color += w * (inputTexture.Sample(samplerState, input.uv + of) +
        inputTexture.Sample(samplerState, input.uv - of));
    }

    return color;
}
