Texture2D albedoTexture : register(t0);
Texture2D normalRoughnessTexture : register(t1);
Texture2D depthTexture : register(t2);
Texture2D shadowMap : register(t3);

SamplerState pointClamp : register(s0);
SamplerComparisonState shadowSampler : register(s1); // D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR and ComparisonFunc = LESS_EQUAL

cbuffer MatrixBuffer : register(b0)
{
	float4x4 invProj;
	float4x4 invView;
};

cbuffer LightBuffer : register(b1)
{
	float4x4 lightViewProj;
	float3 lightDirectionVS;
	float pad0;
	float3 lightColor;
	float pad1;
	float3 ambientColor;
	float pad2;
};

struct PixelInputType
{
	float2 uv : TEXCOORD0;
	float4 position : SV_POSITION;
};

float3 ReconstructViewPos(float2 uv)
{
	float depth = depthTexture.Sample(pointClamp, uv).r;
	float4 clipPos = float4(uv * 2 - 1, depth, 1);
	float4 viewPosH = mul(clipPos, invProj);

	//viewPosH.z = -0.30009002f / (viewPosH.z - 1.00030009f);
	return viewPosH.xyz / viewPosH.w;
}

float4 LightPixelShader(PixelInputType input) : SV_TARGET
{
	const float PI = 3.14159;
	float3 albedo = albedoTexture.Sample(pointClamp, input.uv).rgb;
	float4 nr = normalRoughnessTexture.Sample(pointClamp, input.uv);
	float3 normal = normalize(nr.rgb * 2 - 1);
	float rough = max(nr.a, 0.01);

	float3 viewPos = ReconstructViewPos(input.uv);
	float3 V = normalize(-viewPos);
	float3 L = normalize(-lightDirectionVS);
	float3 H = normalize(V + L);

	float NdotL = saturate(dot(normal, L));
	float NdotV = saturate(dot(normal, V));
	float NdotH = saturate(dot(normal, H));
	float VdotH = saturate(dot(V, H));

	// schlick fresnel
    float3 F0 = float3(0.04, 0.04, 0.04);
    float3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);

	// ggx
	// ndf
	float alpha = rough * rough;
    float alpha2 = alpha * alpha;
    float denomD = (NdotH * NdotH) * (alpha2 - 1.0) + 1.0;
    float D = alpha2 / (PI * denomD * denomD);

    // geometry function
    float k = (alpha + 1.0) * (alpha + 1.0) / 8.0;
    float G_V = NdotV / (NdotV * (1.0 - k) + k);
    float G_L = NdotL / (NdotL * (1.0 - k) + k);
    float G = G_V * G_L;

    float3 specular = (D * G * F) / (4.0 * NdotV * NdotL + 0.001);

    // lambertian diffuse
    float3 diffuse = (1.0 - F) * albedo / PI;

    float3 color = (diffuse + specular) * lightColor * NdotL;

    float3 ambient = albedo * ambientColor;

    return float4(color + ambient, 1.0);
	//return float4(normal, 1.0);
	//return float4(viewPos.rgb, 1);
	//return float4(shadowMap.SampleLevel(pointClamp, input.uv, 0).rrr,1);
};