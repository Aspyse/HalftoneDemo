Texture2D colorTexture : register(t0);
Texture2D normalTexture : register(t1);
SamplerState samplerState : register(s0);

cbuffer CrosshatchBuffer : register(b0)
{
	float2 offset;
	float thicknessMul;
	float topoFreqMul;
	float radFreqMul;

	float3 pad0;
};

struct PixelInputType
{
	float2 uv : TEXCOORD0;
	float4 position : SV_POSITION;
};

// Manually calibrated values
static const float wH = 32;
static const float baseFreqH = 8;

static const float wA = 1;
static const float baseFreqA = 4;

float4 PostprocessShader(PixelInputType input) : SV_Target
{
    float vis = colorTexture.Sample(samplerState, input.uv).r;

	float halfWidthH = wH * 0.5 * thicknessMul;
	float halfWidthA = wA * 0.5 * thicknessMul;

	float freqH = baseFreqH * topoFreqMul;
	float freqA = baseFreqA * radFreqMul;
	
	static float2 textureSize;
	colorTexture.GetDimensions(textureSize.x, textureSize.y);

	float2 offset = float2(1.0, 1.0) / textureSize;

	float3 normal = normalTexture.SampleLevel(samplerState, input.uv, 0).rgb * 2 - 1;

	/* TOPO LINES */
	// TODO: consider sobel
	float h = acos(normal.b);

	float3 nLeft  = normalTexture.Sample(samplerState, input.uv - float2(offset.x, 0)).rgb;
	float3 nRight = normalTexture.Sample(samplerState, input.uv + float2(offset.x, 0)).rgb;
	float3 nUp    = normalTexture.Sample(samplerState, input.uv + float2(0, offset.y)).rgb;
	float3 nDown  = normalTexture.Sample(samplerState, input.uv - float2(0, offset.y)).rgb;

	float dNdx = (acos(nRight.b) - acos(nLeft.b)) * 0.5;  
	float dNdy = (acos(nUp.b)    - acos(nDown.b)) * 0.5;

	float2 gradH = float2(dNdx, dNdy);
	float distTopo = frac(h * freqH) - 0.5;

	float spacingH = 1.0 / freqH;
	float valH = frac(h * freqH);
	float dH = abs(valH - 0.5);
	float gradMagH = length(gradH);
	//float gradMagH = 0.01;
	float pixelDistH = dH / (gradMagH + 1e-5);

	float lineOutH = 1.0 - smoothstep(halfWidthH - 0.5, halfWidthH + 0.5, pixelDistH);

	/* RADIAL LINES */
	float2 Nxy = normalize(normal.xy);
	float angle = atan2(Nxy.g, Nxy.r);

	float dNXdx = ddx(Nxy.x);
	float dNXdy = ddy(Nxy.x);
	float dNYdx = ddx(Nxy.y);
	float dNYdy = ddy(Nxy.y);

	float denom = Nxy.x*Nxy.x + Nxy.y*Nxy.y + 1e-6;

	float dTdx = (Nxy.x*dNYdx - Nxy.y*dNXdx) / denom;
	float dTdy = (Nxy.x*dNYdy - Nxy.y*dNXdy) / denom;
	float gradT = sqrt(dTdx * dTdx + dTdy * dTdy) + 1e-5;

	float fR = angle * freqA;
	float d = abs(frac(fR) - 0.5);
	float pixelDist = d / (gradT * freqA);
	
	float lineOutA = 1.0 - smoothstep(halfWidthA - 0.5, halfWidthA + 0.5, pixelDist);

	/* FINAL COLOR */
	float vis2 = (vis > 0.73) ? 0 : 1;
	vis = (vis > 0.99999) ? 0 : 1;

	float color = 1;
	color -= lineOutH * vis2;
	color -= lineOutA * vis;
	color = saturate(color);
	
    return float4(color, color, color, 1);
}