Texture2D inputTexture : register(t0);
SamplerState samplerState : register(s0);

cbuffer HalftoneBuffer : register(b0)
{
	float2 subdivisions;
	int isMonotone;
    float pad0;
	
	float3 dotColor;
    float pad1;
	
	float3 channelAngles;
	float pad2;
};

struct PixelInputType
{
	float2 uv : TEXCOORD0;
	float4 position : SV_POSITION;
};

static const float smoothness = 0.05;

float2 Rot(float2 uv, float rotation)
{
    float2x2 rotMatrix = float2x2(cos(-rotation), -sin(-rotation),
		sin(-rotation), cos(-rotation));

    return mul(uv, rotMatrix);
}
float2 Unrot(float2 uv, float rotation)
{
    float2x2 invRot = float2x2(cos(rotation), -sin(rotation),
		sin(rotation), cos(rotation));

    return mul(uv, invRot);
}

float2 GetCenterUV(float2 uv, float rotation)
{
	float2 rotUV = Rot(uv, rotation);

	rotUV = floor(rotUV/1) + 0.5f;

	return Unrot(rotUV, rotation);
}

float4 GetBrightness(float2 pixelPos, float rotation)
{
    float2 basis = Rot(pixelPos, rotation);
	
	float2 centerPos = GetCenterUV(pixelPos, rotation);
    float2 centerUV = centerPos * subdivisions;

	float2 delta = centerPos - pixelPos;
	float pixelDist = length(delta);
	pixelDist = pixelDist / 0.7071; // fix magic number

	float4 baseColor = 1 - inputTexture.SampleLevel(samplerState, centerUV, 0);
    float4 cmy = smoothstep(baseColor - smoothness, baseColor + smoothness, pixelDist);
	
	// Closest X neighbor
    float offset = (frac(basis.x) > 0.5) ? 1 : -1;
    float2 xPixelPos = float2(basis.x + offset, basis.y);
    xPixelPos = floor(xPixelPos / 1) + 0.5f;
	
    float2 xCenterPos = Unrot(xPixelPos, rotation);
    float2 xCenterUV = xCenterPos * subdivisions;
	
    float2 xDelta = xCenterPos - pixelPos; // distance to neighbor center
    float xPixelDist = length(xDelta) / 0.7071;
	
    float4 xBaseColor = 1 - inputTexture.SampleLevel(samplerState, xCenterUV, 0);
	
    offset = (frac(basis.y) > 0.5) ? 1 : -1;
    float2 yPixelPos = float2(basis.x, basis.y + offset);
    yPixelPos = floor(yPixelPos / 1) + 0.5f;
	
    float2 yCenterPos = Unrot(yPixelPos, rotation);
    float2 yCenterUV = yCenterPos * subdivisions;
	
    float2 yDelta = yCenterPos - pixelPos; // distance to neighbor center
    float yPixelDist = length(yDelta) / 0.7071;
	
    float4 yBaseColor = 1 - inputTexture.SampleLevel(samplerState, yCenterUV, 0);
	

    float4 xCMY = smoothstep(xBaseColor - smoothness, xBaseColor + smoothness, xPixelDist);
	float4 yCMY = smoothstep(yBaseColor - smoothness, yBaseColor + smoothness, yPixelDist);
	
    float4 outCol = min(cmy, xCMY);
	outCol = min(outCol, yCMY);
    return outCol;
	//return (pixelDist >= cmy) ? 1 : 0;
}

float4 PostprocessShader(PixelInputType input) : SV_Target
{
	float2 pixelPos = input.uv / subdivisions;

    float4 CMY = GetBrightness(pixelPos, channelAngles.x);
	float C = CMY.r;
    float M = GetBrightness(pixelPos, channelAngles.y).g;
    float Y = GetBrightness(pixelPos, channelAngles.z).b;

	float3 color = float3(C, M, Y);

	return float4(color, 1);
	//return CMY;
	//return float4(brightness.rgb,1);
}